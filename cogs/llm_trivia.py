import random
import discord
from discord.ext import commands
from datetime import datetime
import sqlite3
import asyncio
import requests  # Import the requests library
import json
import os
import re  # Import regex module

#### Work in progress, not currently working  ####

class Trivia(commands.Cog):
    """
    A Discord cog that provides a trivia game using AURAcoin.
    Users can bet AURAcoin on trivia questions generated by the LLM to win more AURAcoin.
    """

    def __init__(self, bot):
        """
        Initialize the Trivia cog.

        Args:
            bot: An instance of the Discord bot.
        """
        self.bot = bot
        self.conn = sqlite3.connect('./group_memories/aura_memory.db')
        self.lock = asyncio.Lock()  # To prevent concurrent interactions
        self.model = "llama2"  # Specify the LLM model to use

        # Directory to save user memory files if needed
        self.memory_directory = 'user_memories'
        os.makedirs(self.memory_directory, exist_ok=True)

    def get_auracoin_balance(self, player_id):
        """Get the AURAcoin balance for a player."""
        cursor = self.conn.cursor()
        cursor.execute(
            "SELECT balance FROM auracoin_ledger WHERE player_id = ? ORDER BY transaction_id DESC LIMIT 1",
            (player_id,))
        result = cursor.fetchone()
        return result[0] if result else 0

    def log_command_usage(self, interaction, command_name, input_data, output_data):
        """Logs the command usage to the database.

        Args:
            interaction: The interaction that triggered this command.
            command_name: The name of the command executed.
            input_data: The input provided by the user.
            output_data: The output generated by the command.
        """
        timestamp = datetime.now().isoformat()
        user_id = interaction.user.id
        guild_id = interaction.guild.id if interaction.guild else None
        username = interaction.user.name

        with self.conn:
            self.conn.execute('''
                INSERT INTO logs (log_type, log_message, timestamp, guild_id, user_id, username)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', ('COMMAND_USAGE', f"({username}) executed {command_name}.", timestamp, guild_id, user_id, username))

    @discord.app_commands.command(name="trivia", description="Play a trivia game with AURAcoin betting.")
    @discord.app_commands.describe(amount="The amount of AURAcoin to bet.")
    async def trivia(self, interaction: discord.Interaction, amount: int):
        """Allows a user to play the trivia game."""
        user = interaction.user
        user_id = user.id

        await interaction.response.defer(thinking=True)  # Show 'thinking' indicator

        # Check if the user has enough balance
        balance = self.get_auracoin_balance(user_id)
        if amount <= 0:
            await interaction.followup.send("You need to bet a positive amount of AURAcoin.")
            return
        if amount > balance:
            await interaction.followup.send(f"You have insufficient AURAcoin balance. Your balance is {balance} AC.")
            return

        # Deduct the bet amount from the user's balance
        new_balance = balance - amount
        timestamp = datetime.now().isoformat()
        with self.conn:
            self.conn.execute('''
                INSERT INTO auracoin_ledger (player_id, change_amount, balance, transaction_type, timestamp)
                VALUES (?, ?, ?, ?, ?)
            ''', (user_id, -amount, new_balance, 'trivia_bet', timestamp))

        # Generate a trivia question using the LLM
        question_data = await self.generate_trivia_question()

        if not question_data:
            await interaction.followup.send("Failed to generate a trivia question. Please try again later.")
            # Refund the bet
            new_balance += amount
            with self.conn:
                self.conn.execute('''
                    INSERT INTO auracoin_ledger (player_id, change_amount, balance, transaction_type, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (user_id, amount, new_balance, 'trivia_refund', timestamp))
            return

        question = question_data['question']
        options = question_data['options']
        correct_answer = question_data['answer']

        # Send the question to the user
        options_text = '\n'.join(
            [f"{letter}) {option}" for letter, option in zip(['A', 'B', 'C', 'D'], options)])
        full_question = f"{question}\n\n{options_text}\n\nPlease type your answer (A, B, C, or D)."

        await interaction.followup.send(full_question)

        # Wait for the user's response
        def check(m):
            return m.author == user and m.channel == interaction.channel and m.content.strip().upper() in ['A', 'B', 'C', 'D']

        try:
            response = await self.bot.wait_for('message', check=check, timeout=30.0)
        except asyncio.TimeoutError:
            await interaction.followup.send("You took too long to answer. Bet lost.")
            # No need to update balance (bet already deducted)
            return

        user_answer = response.content.strip().upper()

        # Determine if the user won
        if user_answer == correct_answer:
            winnings = amount * 2  # Double the bet amount
            new_balance += winnings
            with self.conn:
                self.conn.execute('''
                    INSERT INTO auracoin_ledger (player_id, change_amount, balance, transaction_type, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (user_id, winnings, new_balance, 'trivia_win', timestamp))
            await interaction.followup.send(
                f"Correct! You won {winnings} AC!\nYour new balance is {new_balance} AC.")
        else:
            await interaction.followup.send(
                f"Incorrect. The correct answer was {correct_answer}.\nYour new balance is {new_balance} AC.")
            # No need to update balance (bet already deducted)

        # Log the command usage
        self.log_command_usage(
            interaction, "trivia", str(amount),
            f"User answered: {user_answer}, Correct answer: {correct_answer}")

    async def generate_trivia_question(self):
        """Generates a trivia question using the LLM via the Ollama HTTP API.

        Returns:
            dict: A dictionary containing 'question', 'options', and 'answer' keys.
        """
        prompt = (
            "Please generate a general knowledge trivia question suitable for all audiences. "
            "Format your response exactly as follows:\n"
            "Question: [Your question here]\n"
            "A) [Option A]\n"
            "B) [Option B]\n"
            "C) [Option C]\n"
            "D) [Option D]\n"
            "Answer: [A/B/C/D]"
        )

        try:
            # Use the Ollama HTTP API
            url = "http://localhost:11434/api/generate"
            headers = {"Content-Type": "application/json"}
            data = {
                "model": self.model,
                "prompt": prompt
            }
            response = requests.post(url, headers=headers, json=data, stream=True)

            content = ''
            for line in response.iter_lines():
                if line:
                    line = line.decode('utf-8')
                    # Each line is a JSON-formatted string
                    try:
                        data = json.loads(line)
                        content += data.get('response', '')
                    except json.JSONDecodeError:
                        print("Failed to decode JSON line")
                        continue

            # Log the full content for debugging
            print(f"LLM Response:\n{content}")

            # Now parse the content to extract question, options, and answer
            lines = content.strip().split('\n')
            question = ''
            options = []
            answer = None

            # Parse each line
            for line in lines:
                line = line.strip()
                if line.startswith('Question:'):
                    question = line[len('Question:'):].strip()
                elif re.match(r'^[A-D]\)', line):
                    options.append(line[3:].strip())
                elif line.startswith('Answer:'):
                    answer_letter = line[len('Answer:'):].strip().upper()
                    if answer_letter in ['A', 'B', 'C', 'D']:
                        answer = answer_letter

            if question and len(options) == 4 and answer:
                return {'question': question, 'options': options, 'answer': answer}
            else:
                print(f"Failed to parse question. Content received:\n{content}")
                return None

        except Exception as e:
            print(f"Error generating trivia question: {e}")
            return None

# Set up the cog
async def setup(bot):
    """Load the Trivia cog into the bot.

    Args:
        bot: An instance of the Discord bot.
    """
    await bot.add_cog(Trivia(bot))
