import random
import discord
from discord.ext import commands
from datetime import datetime
import sqlite3
import asyncio
import re  # For parsing dice roll strings

class DiceDuel(commands.Cog):
    """
    A Discord cog that provides a dice duel game using AURAcoin.
    Users can challenge each other to a duel by betting AURAcoin, and the winner takes the pot.
    Users can specify custom dice rolls in the format XdY+Z.
    """

    def __init__(self, bot):
        """
        Initialize the DiceDuel cog.

        Args:
            bot: An instance of the Discord bot.
        """
        self.bot = bot
        self.conn = sqlite3.connect('./group_memories/aura_memory.db')
        self.active_challenges = {}  # Key: (challenger_id, challenged_id), Value: dict with 'amount' and 'dice_str'

    def get_auracoin_balance(self, player_id):
        """Get the AURAcoin balance for a player."""
        cursor = self.conn.cursor()
        cursor.execute(
            "SELECT balance FROM auracoin_ledger WHERE player_id = ? ORDER BY transaction_id DESC LIMIT 1",
            (player_id,))
        result = cursor.fetchone()
        return result[0] if result else 0

    def log_command_usage(self, interaction, command_name, input_data, output_data):
        """Logs the command usage to the database.

        Args:
            interaction: The interaction that triggered this command.
            command_name: The name of the command that was executed.
            input_data: The input provided by the user.
            output_data: The output generated by the command.
        """
        timestamp = datetime.now().isoformat()
        user_id = interaction.user.id
        guild_id = interaction.guild.id if interaction.guild else None
        username = interaction.user.name

        with self.conn:
            self.conn.execute('''
                INSERT INTO logs (log_type, log_message, timestamp, guild_id, user_id, username)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', ('COMMAND_USAGE', f"({username}) executed {command_name}.", timestamp, guild_id, user_id, username))

    @discord.app_commands.command(name="challenge", description="Challenge another user to a dice duel with AURAcoin betting.")
    @discord.app_commands.describe(
        opponent="The user you want to challenge.",
        amount="The amount of AURAcoin to bet.",
        dice="The dice roll format (e.g., 2d6+3). Defaults to 'd6' if not specified."
    )
    async def challenge(self, interaction: discord.Interaction, opponent: discord.Member, amount: int, dice: str = "d6"):
        """Allows a user to challenge another user to a dice duel with custom dice."""
        challenger = interaction.user
        challenged = opponent
        challenger_id = challenger.id
        challenged_id = challenged.id

        await interaction.response.defer(thinking=True)

        # Check if the amount is valid
        if amount <= 0:
            await interaction.followup.send("You need to bet a positive amount of AURAcoin.")
            return

        # Check if challenger has enough balance
        challenger_balance = self.get_auracoin_balance(challenger_id)
        if amount > challenger_balance:
            await interaction.followup.send(f"You have insufficient AURAcoin balance. Your balance is {challenger_balance} AC.")
            return

        # Validate the dice string
        try:
            self.parse_dice_roll(dice)
        except ValueError as e:
            await interaction.followup.send(f"Invalid dice format: {str(e)}")
            return

        # Check if challenged user is not a bot
        if challenged.bot:
            await interaction.followup.send("You cannot challenge a bot.")
            return

        # Check if there is already an active challenge between these users
        if (challenger_id, challenged_id) in self.active_challenges or (challenged_id, challenger_id) in self.active_challenges:
            await interaction.followup.send("There is already an active challenge between you two.")
            return

        # Store the challenge
        self.active_challenges[(challenger_id, challenged_id)] = {'amount': amount, 'dice_str': dice}

        # Send a message to the challenged user
        try:
            await challenged.send(
                f"{challenger.mention} has challenged you to a dice duel for {amount} AC using dice `{dice}`! "
                f"Type `/accept` to accept or `/decline` to decline."
            )
            await interaction.followup.send(
                f"You have challenged {challenged.mention} to a dice duel for {amount} AC using dice `{dice}`."
            )
        except discord.Forbidden:
            await interaction.followup.send(f"Could not send a DM to {challenged.mention}. They might have DMs disabled.")

        # Log the command usage
        self.log_command_usage(interaction, "challenge", f"Opponent: {challenged.name}, Amount: {amount}, Dice: {dice}", f"Challenge sent to {challenged.name}.")

    @discord.app_commands.command(name="accept", description="Accept a dice duel challenge.")
    async def accept(self, interaction: discord.Interaction):
        """Allows a user to accept a dice duel challenge."""
        challenged = interaction.user
        challenged_id = challenged.id

        await interaction.response.defer(thinking=True)

        # Find the challenge
        challenge = None
        for (challenger_id, challenged_id_key), data in self.active_challenges.items():
            if challenged_id_key == challenged_id:
                challenge = (challenger_id, challenged_id_key, data)
                break

        if not challenge:
            await interaction.followup.send("You have no pending challenges.")
            return

        challenger_id, challenged_id_key, data = challenge
        amount = data['amount']
        dice_str = data['dice_str']
        challenger = await self.bot.fetch_user(challenger_id)

        # Check if challenged user has enough balance
        challenged_balance = self.get_auracoin_balance(challenged_id)
        if amount > challenged_balance:
            await interaction.followup.send(f"You have insufficient AURAcoin balance. Your balance is {challenged_balance} AC.")
            # Remove the challenge
            del self.active_challenges[(challenger_id, challenged_id)]
            return

        # Deduct bet amounts from both users
        timestamp = datetime.now().isoformat()
        new_challenger_balance = self.get_auracoin_balance(challenger_id) - amount
        new_challenged_balance = challenged_balance - amount

        with self.conn:
            # Deduct from challenger
            self.conn.execute('''
                INSERT INTO auracoin_ledger (player_id, change_amount, balance, transaction_type, timestamp)
                VALUES (?, ?, ?, ?, ?)
            ''', (challenger_id, -amount, new_challenger_balance, 'dice_duel_bet', timestamp))
            # Deduct from challenged
            self.conn.execute('''
                INSERT INTO auracoin_ledger (player_id, change_amount, balance, transaction_type, timestamp)
                VALUES (?, ?, ?, ?, ?)
            ''', (challenged_id, -amount, new_challenged_balance, 'dice_duel_bet', timestamp))

        # Perform the duel using the dice roll logic
        try:
            challenger_result, challenger_rolls, _ = self.parse_dice_roll(dice_str)
            challenged_result, challenged_rolls, _ = self.parse_dice_roll(dice_str)
        except ValueError as e:
            await interaction.followup.send(f"Error in dice rolling: {str(e)}")
            # Refund bets
            with self.conn:
                # Refund challenger
                self.conn.execute('''
                    INSERT INTO auracoin_ledger (player_id, change_amount, balance, transaction_type, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (challenger_id, amount, new_challenger_balance + amount, 'dice_duel_refund', timestamp))
                # Refund challenged
                self.conn.execute('''
                    INSERT INTO auracoin_ledger (player_id, change_amount, balance, transaction_type, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (challenged_id, amount, new_challenged_balance + amount, 'dice_duel_refund', timestamp))
            # Remove the challenge
            del self.active_challenges[(challenger_id, challenged_id)]
            return

        # Determine the winner
        if challenger_result > challenged_result:
            winner = challenger
            loser = challenged
            winner_id = challenger_id
            loser_id = challenged_id
        elif challenged_result > challenger_result:
            winner = challenged
            loser = challenger
            winner_id = challenged_id
            loser_id = challenger_id
        else:
            # It's a tie; refund bets
            with self.conn:
                # Refund challenger
                self.conn.execute('''
                    INSERT INTO auracoin_ledger (player_id, change_amount, balance, transaction_type, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (challenger_id, amount, new_challenger_balance + amount, 'dice_duel_refund', timestamp))
                # Refund challenged
                self.conn.execute('''
                    INSERT INTO auracoin_ledger (player_id, change_amount, balance, transaction_type, timestamp)
                    VALUES (?, ?, ?, ?, ?)
                ''', (challenged_id, amount, new_challenged_balance + amount, 'dice_duel_refund', timestamp))

            # Inform users of the tie
            await interaction.followup.send(
                f"Both rolled {challenger_result}. It's a tie! Bets have been refunded.\n"
                f"{challenger.mention}'s rolls: {', '.join(map(str, challenger_rolls))}\n"
                f"{challenged.mention}'s rolls: {', '.join(map(str, challenged_rolls))}"
            )
            try:
                await challenger.send(
                    f"Your dice duel with {challenged.mention} resulted in a tie. Bets have been refunded."
                )
            except discord.Forbidden:
                pass

            # Remove the challenge
            del self.active_challenges[(challenger_id, challenged_id)]
            return

        # Update winner's balance
        total_pot = amount * 2
        new_winner_balance = self.get_auracoin_balance(winner_id) + total_pot
        with self.conn:
            self.conn.execute('''
                INSERT INTO auracoin_ledger (player_id, change_amount, balance, transaction_type, timestamp)
                VALUES (?, ?, ?, ?, ?)
            ''', (winner_id, total_pot, new_winner_balance, 'dice_duel_win', timestamp))

        # Inform users of the result
        await interaction.followup.send(
            f"{challenger.mention} rolled {challenger_result} ({', '.join(map(str, challenger_rolls))}), "
            f"{challenged.mention} rolled {challenged_result} ({', '.join(map(str, challenged_rolls))}). "
            f"{winner.mention} wins {total_pot} AC!"
        )
        try:
            await challenger.send(
                f"Your dice duel result: You rolled {challenger_result} ({', '.join(map(str, challenger_rolls))}), "
                f"{challenged.mention} rolled {challenged_result} ({', '.join(map(str, challenged_rolls))}). "
                f"{winner.mention} wins {total_pot} AC!"
            )
        except discord.Forbidden:
            pass

        # Log the duel result
        self.log_duel_result(
            challenger_id, challenged_id, amount, winner_id, loser_id, challenger_result, challenged_result,
            ', '.join(map(str, challenger_rolls)), ', '.join(map(str, challenged_rolls)), dice_str
        )

        # Remove the challenge
        del self.active_challenges[(challenger_id, challenged_id)]

        # Log the command usage
        self.log_command_usage(interaction, "accept", "", f"Duel accepted by {challenged.name}. Winner: {winner.name}")

    @discord.app_commands.command(name="decline", description="Decline a dice duel challenge.")
    async def decline(self, interaction: discord.Interaction):
        """Allows a user to decline a dice duel challenge."""
        challenged = interaction.user
        challenged_id = challenged.id

        await interaction.response.defer(thinking=True)

        # Find the challenge
        challenge = None
        for (challenger_id, challenged_id_key), data in self.active_challenges.items():
            if challenged_id_key == challenged_id:
                challenge = (challenger_id, challenged_id_key, data)
                break

        if not challenge:
            await interaction.followup.send("You have no pending challenges.")
            return

        challenger_id, challenged_id_key, data = challenge
        challenger = await self.bot.fetch_user(challenger_id)

        # Inform both users
        await interaction.followup.send(f"You have declined the dice duel challenge from {challenger.mention}.")
        try:
            await challenger.send(f"{challenged.mention} has declined your dice duel challenge.")
        except discord.Forbidden:
            pass

        # Remove the challenge
        del self.active_challenges[(challenger_id, challenged_id)]

        # Log the command usage
        self.log_command_usage(interaction, "decline", "", f"Challenge from {challenger.name} declined.")

    def log_duel_result(self, challenger_id, challenged_id, amount, winner_id, loser_id, challenger_result, challenged_result, challenger_rolls, challenged_rolls, dice_str):
        """Logs the result of a dice duel into the dice_duel_results table."""
        timestamp = datetime.now().isoformat()
        with self.conn:
            self.conn.execute('''
                INSERT INTO dice_duel_results (
                    challenger_id, challenged_id, amount, winner_id, loser_id, challenger_result, challenged_result,
                    challenger_rolls, challenged_rolls, dice_str, timestamp
                )
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                challenger_id, challenged_id, amount, winner_id, loser_id, challenger_result, challenged_result,
                challenger_rolls, challenged_rolls, dice_str, timestamp
            ))

    @discord.app_commands.command(name="duel_history", description="Shows your last 5 dice duels.")
    async def duel_history(self, interaction: discord.Interaction):
        """Displays the user's last 5 dice duels."""
        user = interaction.user
        user_id = user.id

        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT challenger_id, challenged_id, amount, winner_id, challenger_result, challenged_result,
                   challenger_rolls, challenged_rolls, dice_str, timestamp
            FROM dice_duel_results
            WHERE challenger_id = ? OR challenged_id = ?
            ORDER BY timestamp DESC
            LIMIT 5
        ''', (user_id, user_id))
        results = cursor.fetchall()

        if not results:
            await interaction.response.send_message("You have no dice duel history.")
            return

        history_message = "**Your Last 5 Dice Duels:**\n"
        for result in results:
            challenger_id, challenged_id, amount, winner_id, challenger_result, challenged_result, \
            challenger_rolls, challenged_rolls, dice_str, timestamp = result
            challenger = await self.bot.fetch_user(challenger_id)
            challenged = await self.bot.fetch_user(challenged_id)
            winner = await self.bot.fetch_user(winner_id)
            time_str = datetime.fromisoformat(timestamp).strftime("%Y-%m-%d %H:%M:%S")
            opponent = challenged if user_id == challenger_id else challenger
            user_result = challenger_result if user_id == challenger_id else challenged_result
            opponent_result = challenged_result if user_id == challenger_id else challenger_result
            user_rolls = challenger_rolls if user_id == challenger_id else challenged_rolls
            opponent_rolls = challenged_rolls if user_id == challenger_id else challenger_rolls
            outcome = 'won' if winner_id == user_id else 'lost'
            history_message += (
                f"Against {opponent.name} on {time_str} using dice `{dice_str}`:\n"
                f"You rolled {user_result} ({user_rolls}), "
                f"They rolled {opponent_result} ({opponent_rolls}). "
                f"You **{outcome}** {amount * 2} AC.\n"
            )

        await interaction.response.send_message(history_message)

        # Log the command usage
        self.log_command_usage(interaction, "duel_history", "", "Displayed duel history.")

    @discord.app_commands.command(name="cancel_challenge", description="Cancel your pending dice duel challenge.")
    async def cancel_challenge(self, interaction: discord.Interaction):
        """Allows a user to cancel their pending challenge."""
        challenger = interaction.user
        challenger_id = challenger.id

        await interaction.response.defer(thinking=True)

        # Find the challenge
        challenge = None
        for (challenger_id_key, challenged_id), data in self.active_challenges.items():
            if challenger_id_key == challenger_id:
                challenge = (challenger_id_key, challenged_id, data)
                break

        if not challenge:
            await interaction.followup.send("You have no pending challenges to cancel.")
            return

        challenger_id_key, challenged_id, data = challenge
        challenged = await self.bot.fetch_user(challenged_id)

        # Inform both users
        await interaction.followup.send(f"You have canceled the dice duel challenge to {challenged.mention}.")
        try:
            await challenged.send(f"{challenger.mention} has canceled the dice duel challenge.")
        except discord.Forbidden:
            pass

        # Remove the challenge
        del self.active_challenges[(challenger_id, challenged_id)]

        # Log the command usage
        self.log_command_usage(interaction, "cancel_challenge", "", f"Challenge to {challenged.name} canceled.")

    def parse_dice_roll(self, dice_str: str):
        """
        Parses a dice roll string in the form of XdY+Z and calculates the result.

        Args:
            dice_str: The dice roll string to parse (e.g., 2d6+4, d20).

        Returns:
            Tuple containing:
            - result: The total sum of the dice roll with the modifier.
            - rolls: A list of individual dice rolls.
            - modifier: The numeric modifier applied to the result.
        """
        # Regex to match patterns like '2d6+4', 'd20', '4d8', or 'd12-2'
        dice_pattern = r"(?:(\d*)d)?(\d+)([+-]\d+)?"
        match = re.fullmatch(dice_pattern, dice_str.replace(" ", ""))  # Remove spaces before matching

        if not match:
            raise ValueError("Invalid dice format. Please use a format like 2d6+4 or d20.")

        num_dice = int(match.group(1)) if match.group(1) else 1  # Number of dice to roll, defaults to 1
        dice_size = int(match.group(2))  # Size of dice (e.g., 6 for d6, 20 for d20)
        modifier = int(match.group(3)) if match.group(3) else 0  # Modifier, defaults to 0 if not present

        if num_dice < 1 or dice_size < 1:
            raise ValueError("Number of dice and size must be greater than 0.")

        # Roll the dice
        rolls = [random.randint(1, dice_size) for _ in range(num_dice)]
        result = sum(rolls) + modifier

        return result, rolls, modifier

# Set up the cog
async def setup(bot):
    """Load the DiceDuel cog into the bot.

    Args:
        bot: An instance of the Discord bot.
    """
    await bot.add_cog(DiceDuel(bot))
